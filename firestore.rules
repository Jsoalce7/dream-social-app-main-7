rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    // Helper functions
    function isSignedIn() {
      return request.auth != null;
    }
    function isUser(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }
    function userExists(userId) {
      return exists(/databases/$(database)/documents/users/$(userId));
    }
    function getUserData(userId) { // Renamed for clarity, used to be getUserRole
      return get(/databases/$(database)/documents/users/$(userId)).data;
    }
    function isAdmin() {
      return isSignedIn() && userExists(request.auth.uid) && getUserData(request.auth.uid).role == 'admin';
    }
    function isCoach() { // Kept for consistency if used elsewhere
      return isSignedIn() && userExists(request.auth.uid) && getUserData(request.auth.uid).role == 'coach';
    }
    // For DM thread IDs: uid1_uid2 where uid1 < uid2
    function getThreadId(uid1, uid2) {
      let u1 = string(uid1);
      let u2 = string(uid2);
      return u1 < u2 ? u1 + '_' + u2 : u2 + '_' + u1;
    }
    // Checks if current user is a participant by reading the thread document directly
    function isParticipant(threadId) {
      let threadDocData = get(/databases/$(database)/documents/dmThreads/$(threadId)).data;
      // Assumes participantIds is an array of 2 UIDs.
      return isSignedIn() && (request.auth.uid == threadDocData.participantIds[0] || request.auth.uid == threadDocData.participantIds[1]);
    }
    // Checks if current user is a participant using provided thread document data (resource.data or request.resource.data)
    // Assumes participantIds is an array of 2 UIDs.
    function isThreadParticipant(threadDocData) {
      return isSignedIn() && (request.auth.uid == threadDocData.participantIds[0] || request.auth.uid == threadDocData.participantIds[1]);
    }

    // Users collection
    match /users/{userId} {
      allow read: if isSignedIn();
      allow create: if isUser(userId) &&
                       request.resource.data.keys().hasAll(['id', 'email', 'fullName', 'createdAt', 'role']) &&
                       request.resource.data.id == userId &&
                       request.resource.data.role == 'user'; // Default role on creation, ensure all fields present
      allow update: if isSignedIn() &&
                      ( (isUser(userId) &&
                         !('diamonds' in request.resource.data) && // User cannot update their own diamonds
                         !('role' in request.resource.data) // User cannot update their own role
                        ) ||
                        isAdmin() // Admin can update anything
                      );
      allow delete: if isAdmin();
    }

    // Direct Message Threads
    match /dmThreads/{threadId} {
      allow read: if isThreadParticipant(resource.data);

      allow create: if isSignedIn() &&
                       request.auth.uid in request.resource.data.participantIds &&
                       threadId == getThreadId(request.resource.data.participantIds[0], request.resource.data.participantIds[1]) &&
                       request.resource.data.participantIds.size() == 2 &&
                       // Ensure both participant IDs resolve to existing users
                       userExists(request.resource.data.participantIds[0]) &&
                       userExists(request.resource.data.participantIds[1]) &&
                       request.resource.data.keys().hasAll(
                         ['participantIds', 'participantProfiles', 'createdAt', 'updatedAt', 'lastMessage']
                       ) &&
                       request.resource.data.participantProfiles.keys().hasAll(request.resource.data.participantIds) &&
                       request.resource.data.createdAt == request.time &&
                       request.resource.data.updatedAt == request.time;

      allow update: if isThreadParticipant(resource.data) &&
                       // Allow updates to lastMessage, updatedAt, and unreadCounts by participants
                       request.resource.data.keys().hasAny(['lastMessage', 'updatedAt', 'unreadCounts']) &&
                       request.resource.data.updatedAt == request.time &&
                       // Ensure critical fields are not changed by this update
                       request.resource.data.participantIds == resource.data.participantIds &&
                       request.resource.data.participantProfiles == resource.data.participantProfiles &&
                       request.resource.data.createdAt == resource.data.createdAt;


      // Nested Direct Messages subcollection
      match /directMessages/{messageId} {
        allow read: if isParticipant(threadId); // Use parent thread's ID to check participation

        allow create: if isParticipant(threadId) &&
                         request.resource.data.senderId == request.auth.uid &&
                         request.resource.data.threadId == threadId &&
                         request.resource.data.keys().hasAll([
                           'senderId', 'receiverId', 'content', 'contentType', 'timestamp', 'threadId', 'senderProfile'
                           // 'isReadBy' might be part of this or handled by updates
                         ]) &&
                         request.resource.data.timestamp == request.time &&
                         // Ensure receiverId is the other participant
                         ( (request.auth.uid == get(/databases/$(database)/documents/dmThreads/$(threadId)).data.participantIds[0] &&
                            request.resource.data.receiverId == get(/databases/$(database)/documents/dmThreads/$(threadId)).data.participantIds[1]) ||
                           (request.auth.uid == get(/databases/$(database)/documents/dmThreads/$(threadId)).data.participantIds[1] &&
                            request.resource.data.receiverId == get(/databases/$(database)/documents/dmThreads/$(threadId)).data.participantIds[0])
                         );

        // Generally, users should not update/delete DMs. Admins could.
        allow update, delete: if isAdmin();
      }
    }

    // Admin configuration (existing)
    match /admin/config {
      allow read: if isSignedIn();
      allow write: if isAdmin();
    }

    // Battles collection (existing - structure maintained)
    match /battles/{battleId} {
      allow read: if isSignedIn() && ( isAdmin() || request.auth.uid == resource.data.creatorAId || request.auth.uid == resource.data.creatorBId );
      allow create: if isSignedIn() && request.resource.data.creatorAId == request.auth.uid && request.resource.data.requestedBy == request.auth.uid && request.resource.data.keys().hasAll(['creatorARef', 'creatorBRef', 'creatorAId', 'creatorAName', 'creatorAAvatar', 'creatorBId', 'creatorBName', 'creatorBAvatar', 'dateTime', 'mode', 'status', 'requestedBy', 'createdAt']) && request.resource.data.creatorARef == /databases/$(database)/documents/users/$(request.resource.data.creatorAId) && request.resource.data.creatorBRef == /databases/$(database)/documents/users/$(request.resource.data.creatorBId);
      allow update: if isSignedIn() && ( isAdmin() || ( resource.data.status == 'pending' && request.auth.uid == resource.data.creatorBId && request.resource.data.keys().hasOnly(['status']) && (request.resource.data.status == 'accepted' || request.resource.data.status == 'declined') ) );
      allow delete: if isAdmin();
    }

    // Channels and their messages (existing - structure maintained)
    match /channels/{channelId} {
      allow read: if isSignedIn();
      allow create: if isSignedIn() && (isAdmin() || isCoach()) && request.resource.data.createdBy == request.auth.uid && request.resource.data.name is string && (request.resource.data.description is string || !('description' in request.resource.data)) && request.resource.data.keys().hasAny(['name','description','createdBy','createdAt']);
      allow update: if isAdmin();
      allow delete: if isAdmin();

      match /messages/{messageId} {
        allow read: if isSignedIn();
        allow create: if isSignedIn() && request.resource.data.senderId == request.auth.uid && request.resource.data.channelId == channelId;
        allow update, delete: if isAdmin() || (isSignedIn() && request.auth.uid == resource.data.senderId);
      }
    }
  }
}
                     request.resource.data.userId == request.auth.uid &&
                     userExists(string(request.resource.data.userId)) && // Ensure creator of message exists
                     request.resource.data.keys().hasAll(['userId', 'userName', 'userAvatar', 'message', 'timestamp', 'channelId', 'type', 'battleId']) &&
                     request.resource.data.battleId is string;
      // allow update: if isAdmin();
      // allow delete: if isAdmin();
    }

    // Modification Requests collection
    match /modificationRequests/{requestId} {
      allow create: if isSignedIn() &&
                       request.resource.data.requestingUserId == request.auth.uid &&
                       request.resource.data.keys().hasAll(['battleId', 'requestingUserId', 'proposedChanges', 'status', 'createdAt']) &&
                       request.resource.data.status == 'pending' &&
                       (get(/databases/$(database)/documents/battles/$(request.resource.data.battleId)).data.creatorAId == request.auth.uid ||
                        get(/databases/$(database)/documents/battles/$(request.resource.data.battleId)).data.creatorBId == request.auth.uid
                       );

      allow read: if isSignedIn() &&
                      ( isAdmin() ||
                        (get(/databases/$(database)/documents/battles/$(resource.data.battleId)).data.creatorAId == request.auth.uid ||
                         get(/databases/$(database)/documents/battles/$(resource.data.battleId)).data.creatorBId == request.auth.uid
                        )
                      );

      allow update: if isAdmin() &&
                      request.resource.data.keys().hasAll(['battleId', 'requestingUserId', 'proposedChanges', 'status', 'createdAt', 'updatedAt']);

      allow delete: if isAdmin();
    }
  }
}
